let rest
	lambda (array)
		slice array 1

let .wrap-do
	lambda exps
		with (l (count exps))
			if (= l 0) nil
				if (= l 1) (first exps)
					# else
					cons (quote do) exps

let macro
	macrof (key args .. body)
		do
			if (not (ist List args))
				let args (list args)
			if (< (count body) 1)
				throw (str 'Empty macro body: ' key)
			quasiquote
				let (unq key)
					macrof (unq args)
						unq (.wrap-do body)

macro amacro (params .. body)
	if (< (count body) 1)
		throw 'Empty f body'
	qq
		macrof (unq params)
			unq (.wrap-do body)


macro alias (key target)
	quasiquote
		macro (unq key) (.. args)
			cons
				quote (unq target)
				args

# aliases are only needed for special forms
alias q quote
alias qq quasiquote
# core functions can be aliased with let
let li list

macro f (params .. body)
	if (< (count body) 1)
		throw 'Empty f body'
	qq
		lambda (unq params)
			unq (.wrap-do body)

macro fn (name params .. body)
	if (< (count body) 1)
		throw (str 'Empty fn body:' name)
	qq
		let (unq name)
			lambda
				unq params
				unq (.wrap-do body)

fn each (values func)
	unless (or
		is-list values
		is-string values
	)
		throw (str 'each argument list: Type error [expected=list|string, got=' values ']')
	unless (is-func func)
		throw (str 'each argument func: Type error [expected=function], got=' func ']' )
	fn .each (values)
		unless (is-empty values) (do
			func (first values)
			.each (rest values)
		)
	.each values

fn is-empty arg
	= (count arg) 0

fn flatten (values)
	if (is-empty values)
		()
		if (is-empty (first values))
			flatten (rest values)
			cons
				first (first values)
				flatten
					cons
						rest (first values)
						rest values

# overwrite only if not specified by host language for performance reasons
let concat
	if concat concat
		f (.. values)
			flatten values

fn append (values .. more)
	concat
		values
		more

fn map (values func)
	unless (or
		is-list values
		is-string values
	)
		throw (str 'map argument list: Type error [expected=list|string, got=' values ']')
	unless (is-func func)
		throw (str 'map argument func: Type error [expected=function], got=' func ']' )
	fn agg (values)
		if (is-empty values) ()
			# else
			cons
				func (first values)
				agg (rest values)
	agg values


fn range (start end)
	if (is-nil end)
		range 0 start
		if
			>= start end
			()
			cons
				start
				range (+ start 1) end

macro cond (.. args)
	if (> (count args) 0)
		# handle else
		unless (= (first args) (q else))
			# it's not an else clause, so check condition
			li (q if) (first args)
				if (> (count args) 1)
					nth args 1
					# else
					throw "odd number of forms to cond"
				# "else" recurse with rest of args
				cons
					q cond
					rest (rest args)
			# else it's an else clause, so just return the next expression
			nth args 1

#
	optional hierarchical get from dict
#

fn optget (obj .. keys)
	cond
		= obj nil
		nil

		= (count keys) 0
		obj

		true
		apply optget
			get obj (first keys)
			rest keys

# TODO: rename? Also would be nice to have as macro / lazy evaluation
fn coalesce (.. vals)
	let head (first vals)
	if
		not (= head nil)
		# then
		head
		# else
		apply coalesce
			rest vals

# TODO: is this really needed?
macro increment var
	qq
		let (unq var) (+ (unq var) 1)

macro unless (condition body alternative)
	if (is-undefined alternative)
		qq
			if
				not (unq condition)
				unq body
		qq
			if
				not (unq condition)
				unq body
				unq alternative

macro or (.. args)
	if (is-empty args)
		false
		li
			q unless
			first args
			cons
				q or
				rest args
			true

macro and (.. args)
	if (is-empty args)
		true
		li
			q if
			first args
			cons
				q and
				rest args
			false

macro load-file filename
	qq
		eval
			read-string
				file-read (unq filename)
				dict 'filename' (unq filename)

# caching of required files
let .required
	var (dict)

macro require (.caller filename .. require-keys)
	if (str-starts-with filename '~')
		let filename
			str .tabhome (slice filename 1)
	# get position from caller function
	let position-filename
		optget .caller 'position' 'filename'
	qq
		(f (env filename)
			let position-filename (unq position-filename)
			let require-keys (quote (unq require-keys))
			let basedir
				unless (= position-filename nil)
					# then
					dirname position-filename
					# else
					.cwd
			let filename-abs
				path-resolve basedir filename
			unless (has (deref .required) filename-abs) (do
				let new-env (env-new .env-root)
				eval
					read-string
						file-read filename-abs
						dict 'filename' filename-abs
					new-env
				swap .required set filename-abs (get new-env 'data')
			)
			let data
				get (deref .required) filename-abs
			let let-keys
				if (= (count require-keys) 0)
					keys data
					require-keys
			map let-keys
				f let-key
					env-set env let-key (get data let-key)
		) .env (unq filename)

fn varply (var func .. args)
	apply func (deref var) args

fn swap (var func .. args)
	reset var
		apply func (deref var) args

fn pr-str (.. args)
	str-join
		map
			args
			f arg (print-string arg true)
		' '

fn str (.. args)
	str-join
		map
			args
			f arg (print-string arg false)
		''

fn print (.. args)
	output
		apply
			pr-str
			args
	nil

fn debug (.. args)
	output args
	nil

fn println (.. args)
	output
		str-join
			map
				args
				f arg (print-string arg false)
			' '
	nil

fn is-bool arg
	ist Boolean arg

fn is-list arg
	ist List arg

fn is-var arg
	ist Var arg

fn is-nil arg
	ist Nil arg

fn is-map arg
	ist Map arg

fn is-symbol arg
	ist Symbol arg

fn is-func arg
	ist Function arg

fn != (a b) (not (= a b))

fn index-of (values element)
	fn -index-of (values index)
		if (is-empty values) nil
			if (= element (first values)) index
				-index-of (rest values) (+ index 1)
	-index-of values 0

require '~/tabjs/math.tab'